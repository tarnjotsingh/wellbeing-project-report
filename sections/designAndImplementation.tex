\section{Design and Implementation}

At this point the project has a set of requirements to meet and basic solution approach has been outlined for each aspect of 
the project.
This section aims to inform the reader of the detailed design choices made and how this was implemented to achieve the final product.

\subsection{System model design} \label{system model design}

\begin{figure}[ht]
    \centering
    \includegraphics[width=450px]{images/system_model.png}
    \caption{Proposed system model}
    \label{proposedsystemmodel}
\end{figure}


The proposed system model outlines the method in which an \textit{expert} can create, edit or delete a survey and how this can be 
fed to a student.
The main functionality to point out, that really links the two user types together, is how new survey send some sort notification 
to a (potentially) subscribed student; leading them to respond to the survey.
From the diagram, the reader should be able to see how a student will be able to either view surveys at their own will or be prompted
by a notification that had been sent out by some service.
The system outlines that there are really only two different categories of user that will use the system, this makes sense when looking
back at the articulation of the problem and the original brief given.

\clearpage
\subsection{Flow diagram}

An important process for the software solution is to be able to add and modify surveys for students to respond to.
The system model design does not go into much detail about this part of the system so it will be important to gain some clarity around this area.
Below is the proposed process flow diagram for what will occur when a user, of the system, attempts to add a new survey.
It outlines the need for authorisation (have permission to access such a resource) before carrying out two steps of validation of the
data provided.
If validation passes, then the survey and survey questions entries will be added to the database.
As mentioned in the system model design, there is a mention of the notification service that will alert students about a new survey they
can participate in.
The flow diagram shows how an expert can be prompted about sending out an alert to students, after submitting the survey.
That is where the system will then move onto executing the notification service, or just conclude the current process flow.

\begin{figure}[ht]
    \centering
    \includegraphics[width=150px]{images/flow_diagram.png}
    \caption{Flow diagram of the processes involved when an \textit{expert} adds a new survey}
\end{figure}

\clearpage

\subsection{Database (data layer)}
The database is important to get right as the design needs to store surveys data in a logical structured manner.
To understand what is required for the database, it makes sense to first break it down and understand relationships between
each entity.

\begin{enumerate}
    \item Each \textit{survey} will have a survey name or title and has a \textit{one-to-many} relationship with \textit{survey questions}.
    \item Each \textit{survey question} will have a question name and will have a \textit{one-to-many} relationship with \textit{question choices}.
    \item Each \textit{question choice} will have a choice name with an associated weight.
    \item To store user choices for a \textit{survey question} a \textit{user question choice} entity can be used.
        \begin{enumerate}
            \item Each \textit{user question choice} will have a \textit{many-to-one} relationship with a \textit{survey question} and \textit{question choice}
        \end{enumerate}
\end{enumerate}

To map out these relationships, into a diagram that can be visually understood, JDL (JHipster Domain Language) was used.
The JDL approach allows for a more logical approach of designing a database since it avoids any confusion from a purely visual approach.
Below is the JDL written with the associated diagram representation.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=JDL]
entity UserQuestionChoice {
	timeStamp Timestamp
}
entity Choice {
	choice String,
    weight Integer
}
entity Question {
	question String
}
entity Survey {
	description String
}
relationship OneToMany {
    Survey{survey} to Question{survey}
	Question{question} to Choice
}
relationship ManyToOne {
    UserQuestionChoice to Question
    UserQuestionChoice to Choice
}
    \end{lstlisting}
    \caption{JDL based on the breakdown of what will be needed to store surveys}
\end{figure}

\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=250px]{images/jhipster-jdl.png}
    \caption{Graph produced by JDL-studio}
    \label{survey-jdl-graph}
\end{figure}

Since initial prototyping is being done using the JHipster framework, it makes sense to take advantage of tools such as 
JDL-studio to produce diagrams such as \ref{survey-jdl-graph}.
To fully take advantage of the JDL written, it can be imported into the JHipster project currently being worked on. 
The functionality of value that will be desired from the import process will be a set of generated classes that represent
the database schema and will serve as a starting point.
Generating the classes from the schema is a great way to have the correct relationships set up however many adjustments will
need to be made to achieve the desired behaviour.

\subsubsection{Java Persistence API}
An SQL database schema can be created in Java itself with the help of Hibernate. % You might want to go over this in the lit review.
Hibernate will facilitate the mapping of object-orientated domains, created in Java, to the corresponding tables in a relational database.
The Java Persistence API (JPA) set of packages will provide the necessary annotations to correctly set up classes that represent \textit{tables}.
Figure \ref{question object} shows how a class, with all the required annotations, can be created.
Domain classes that are created, as a part of the Java code, use the Java Persistence API (JPA) set of packages.
The JPA packages provide the required annotations to be used in a class to allow a chosen mapping tool (Hibernate in this case) to understand how
to map class objects into database tables.
Cascading options are also available to allow actions on an entry in the table to be reflected on any child entities.
In the example below, cascading is used to ensure that if a \textit{question} is removed from the database, any \textit{question choices} associated
with it are also removed; ensuring no orphan entries are produced in the database.

\clearpage
\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Java, escapechar=|]
@Entity
@Table(name = "question")
public class Question implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "question")
    private String question;
    
    @OneToMany(mappedBy = "question", cascade = CascadeType.ALL)
    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
    private Set<Choice> questionChoices = new HashSet<>();
    
    @ManyToOne(fetch = FetchType.EAGER, optional = false)
    @JoinColumn(name = "survey_id", nullable = false)
    @JsonIgnore
    private Survey survey;
    
    @OneToMany(mappedBy = "question", cascade = CascadeType.ALL)
    private Set<UserQuestionChoice> userQuestionChoices = new HashSet<>();
    |\dots
}    
    \end{lstlisting}
    \caption{Question object to be mapped to a database table}
    \label{question object}
\end{figure}


The benefit of this approach is that the database schema can be controlled programatically and also allows for repository interfaces to be created.
Repository interfaces is what is used to invoke actions against the corresponding table in the database.
A notable feature of these interfaces is that they allow for \textit{derived} methods to be written without having to write any logic for it.
The idea behind these derived methods is that it gives flexibility to the developer to incorporate query methods to a specific problem.
It is also important to note that there is no SQL being written as a part of the code; only Java code is being written.


\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Java]
@Repository
public interface QuestionRepository extends JpaRepository<Question,Long> 
{
    List<Question> findBySurveyId(Long surveyId);
    Optional<Question> findByIdAndSurveyId(Long id, Long surveyId);
    boolean existsByIdAndSurveyId(Long id, Long surveyId);

    @Transactional
    @Modifying
    void deleteByIdAndSurveyId(Long id, Long surveyId);
}
    \end{lstlisting}
    \caption{Repository interface for Question domain/table}
    \label{repo example}
\end{figure}


Now that the main Java components have been covered, Spring will need to be configured to actually connect to a database.
For this project, a MySQL container will be configured. To do this, a \textit{docker compose} file can be created.
As shown in figure \ref{sqldocker}, the file allows for environment variables and exposed ports to be specified.
Once the file is ready, the command \textit{docker-compose up compose.yml} can be run.
This command will pull down the docker image and automatically start it along with applying the specified options in the file.
After logs start appearing in the command-line, a connection attempt to the database can be made using a tool such as MySQLWorkbench.
Using a tool such as MySQLWorkbench is important as it allows for manual SQL queries to be run against the database and verify that operations
executed by hibernate are doing the right thing.


\begin{figure}[ht]
    \centering
    \begin{lstlisting}
#compose version of 3.3        
version: '3.3'
services:
  db:
    image: mysql
    restart: always
    environment:
      MYSQL_DATABASE: 'springdb'
      MYSQL_USER: 'admin'
      MYSQL_PASSWORD: 'admin'
      MYSQL_ROOT_PASSWORD: 'password'
      lower_case_table_names: '1'
      character_set_server: 'utf8'
    ports:
      # <Port exposed> : < MySQL Port running inside container>
      - '3306:3306'
    expose:
      # Opens port 3306 on the container
      - '3306'           
    \end{lstlisting}
    \caption{Docker compose yaml file for a mysql image from dockerhub}
    \label{sqldocker}
\end{figure}

Spring still needs to be configured to actually connect to this database running in a container.
The details required will be the database name with valid login credentials.
An application.yml (yaml file) is used by spring to configure various aspects of the project, depending on what is required by the developer.
Below, in figure \ref{springymldbconfig}, the reader can see the simple configuration needed to get a database connection set up.
The SpringBoot application will automatically read and apply the configuration on the initial start up; if anything is wrong with the config,
and exception will be thrown and stop the server.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[escapechar=|]
spring:
    datasource:
        url: jdbc:mysql://localhost:3306/springdb
        driver-class-name: com.mysql.cj.jdbc.Driver
        username: root
        password: password
    jpa:
        database: mysql
        show-sql: true
        hibernate:
            ddl-auto: update |\label{hibernate option}|
    \end{lstlisting}
    \caption{Snippet from application.yml for configuring the spring project}
    \label{springymldbconfig}
\end{figure}

\clearpage
\subsubsection{Final DB schema}

\begin{figure}[ht]
    \centering
    \includegraphics[width=300px]{images/db_schema.png}
    \caption{Database schema diagram produced from MySQLWorkbench}
    \label{sqldbschamfull}
\end{figure}

Once everything has been correctly configured, the SpringBoot application can be run.
Line \ref{hibernate option}, in figure \ref{springymldbconfig} be set to either \textit{create} or \textit{update}.
The main difference between the two is that \textit{create} will always overwrite any existing schema whereas \textit{update} will not.



\subsection{REST API}
% Talk about how it is going to be used
% Outline the main endpoints that need to be implemented
% Detail the endpoints that have been implemented and what they do

The REST API, to be implemented, is going to be a very important part of this project as it will be means of communicating between
the server and client. 
As mentioned in section \ref{restliterature}, a set of URL based endpoints will need to be defined as a part of the API 
documentation.
The URL paths themselves will be based on the type of access needed to resources of the system, most notably survey and user data.
Since this is an application that focuses on creating and responding to surveys, the API defined will have to focus on that.
The REST endpoints will be based on the system model diagram in section \ref{system model design} as it outlines the use cases 
of the system.

\subsubsection{API Design}
Designing the API will heavily revolve around the database schema as shown in figure \ref{sqldbschamfull}.
For this project, Swagger2 (OpenAPI2) will be used to define the API and produce the necessary API documentation.
This section will just cover all the of API paths that have been implemented with a basic description for each; full 
API documentation is available in the appendix.

\subsubsection*{Surveys resource}
Resource path: /api/surveys

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get all surveys as a list \\
      \textbullet~ POST & Create a new survey \\
      \textbullet~ PUT & Update an existing survey \\
    \end{tabular}
\end{listliketab}

\noindent
Resource path: /api/surveys/\{id\}

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get a survey with a given ID. \\
      \textbullet~ DELETE & Delete a survey with a given ID. \\
    \end{tabular}
\end{listliketab}

\subsubsection*{Questions resource}
Resource path: /api/surveys/\{surveyId\}/questions

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get all questions for a given survey with specified ID as a list. \\
      \textbullet~ POST & Create a new question for survey with specified \\
      \textbullet~ PUT & Update an existing question in a given survey with specified ID.
    \end{tabular}
\end{listliketab}


\noindent
Resource path: /api/surveys/\{surveyId\}/question/\{questionId\}

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get a specified question for a specified survey. \\
      \textbullet~ DELETE & Delete a specified question for a specified survey. \\ 
    \end{tabular}
\end{listliketab}


\subsubsection*{Choices resource}

Resource path: /api/surveys/\{surveyId\}/question/\{questionId\}/choices

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get all choices for a specified question for a specified survey. \\
      \textbullet~ POST & Create a new choice for a specified question for a specified survey. \\ 
      \textbullet~ PUT & Update an existing choice for a specified question for a specified survey.
    \end{tabular}
\end{listliketab}

\noindent
Resource path: /api/surveys/\{surveyId\}/question/\{questionId\}/choices/\{choiceId\}

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get a specified choice for a specified question for a specified survey. \\
      \textbullet~ DELETE & Delete a specified choice for a specified question for a specified survey. \\ 
    \end{tabular}
\end{listliketab}

\subsubsection*{User resource}

Resource path: /api/users

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get all users as a list. \\
      \textbullet~ POST & Create/Register a new user. \\ 
      \textbullet~ PUT & Update user information.\\
    \end{tabular}
\end{listliketab}

\clearpage
\subsubsection{Java implementation}

In REST, access to resources are controlled by REST controllers.
These controller classes therefore need to be implemented.
Spring comes with a set of annotations that be used to mark certain classes as REST controller.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Java, escapechar=|]
@RestController
@RequestMapping("/api")
public class QuestionResource {
    private final Logger log = LoggerFactory.getLogger(QuestionResource.class);
    private static final String ENTITY_NAME = "question";
    private final SurveyRepository surveyRepository;
    private final QuestionRepository questionRepository;

    @Autowired
    public QuestionResource(QuestionRepository questionRepository, SurveyRepository surveyRepository) {
        this.questionRepository = questionRepository;
        this.surveyRepository = surveyRepository;
    }
    ...
    @PostMapping("/surveys/{surveyId}/questions")
    public ResponseEntity<Question> createQuestionForSurvey(@PathVariable (value = "surveyId") Long surveyId, @RequestBody Question question) throws URISyntaxException {
        log.debug("REST request to save Question : {} in survey : {}", question, surveyId);
        if (question.getId() != null) {
            throw new BadRequestAlertException("A new question cannot already have an ID", ENTITY_NAME, "idexists");
        }
        Question toReturn = surveyRepository.findById(surveyId).map(survey -> {     |\label{repousage}|
            question.setSurvey(survey);
            return questionRepository.save(question);
        }).orElseThrow( () -> new ResourceNotFoundException("Survey with ID " + surveyId + " not found."));

        return ResponseEntity.created(new URI("/api/surveys/" + surveyId + "/questions/" + toReturn.getId()))
                .headers(HeaderUtil.createEntityCreationAlert(ENTITY_NAME, toReturn.getId().toString()))
                .body(toReturn);
    }
    ...
}      
    \end{lstlisting}
    \caption{REST controller snippet for question resource}
    \label{restcontrollerexample}
\end{figure}

The code shown in figure \ref{restcontrollerexample} is a snippet of code that is used in the REST controller for managing access to the question resouce.
For the sake of simplicity, all the code was done under each of the mapping methods in the class.
What you may see, in more flushed out examples, is that a lot of the functionality is reserved to REST service classes that can be used in the controllers.

Tags such as \textit{@PostMapping} allows an API endpoint to be defined with the HTTP request type.
The return type of the method is what will be returned in the body of the response of the request.
If an error is encountered while trying to process the request, the appropriate error will be thrown and result in the associated response (such as 404 Not Found).
This process is repeated for all the different endpoints that need to be implemented.
Depending on the type of HTTP request, the underlying logic will obviously be different. 
Line \ref{repousage} in figure \ref{restcontrollerexample} also demonstrates how queries to the underlying database can be made through the appropriate
repository interface.

\subsubsection{Swagger documentation}
Swagger2 (OpenAPI2) is enabled for this project so swagger related endpoints are available.
The most notable (and useful) endpoint provided is \textit{/swagger-ui.html} as it provides an interactive API documentation page.
Other packages that are brought into the project, such as Spring Security, provide a set of endpoints as a part of their functionality which
the developer would not know about unless the relevant documentation was read. 
Using the swagger ui, these hidden endpoints are also exposed.
Each of the endpoints listed can be expanded to show the type of body is accepted as a part of the request and lists all the potential 
returns types and what to expect in the response body for each of them.

\begin{figure}[ht]
    \centering
    \includegraphics[width=320px]{images/swagger-ui.png}
    \caption{View of the swagger ui from the browser}
    \label{swaggerui}
\end{figure}

\clearpage
\subsection{Spring Security}

Restrictions needs to be made to who can access the API, particularly with endpoints related to accessing user data.
To secure these endpoints, Oauth2 with Json Web Tokens will be used to authenticate and authorise users.
The following subsections will cover the Spring Security related configurations required to get this functionality working.

% - Web security configuration
% - Authorization server

% In order to do this, there are three impor


\subsubsection{Web security configuration}
The first part to get security implemented into the Java Spring project is to configure the \textit{WebSecurityConfigurerAdapter}.
This adapter, that is extended, allows customisations to both WebSecurity and HttpSecurity.
The adapter class and the \textit{@EnableWebSecurity} annotation work together to provide web based security \cite{winch2013springsecurity}.
Really basic authentication can be achieved by defining in-memory credentials which can be used with HTTP basic auth.

Basic auth is not going to be secure enough for any modern system and credentials need to be stored in a database; not in memory.
In order to get user details to be stored in the database, a custom authentication provider will need to be created.
A DaoAuthenticationProvider object will need to be created and given to the authentication provider method.
The authentication provider needs to have a Spring user details service and a password encoder to be specified.
Specifying the password encoder is trivial as Spring Security comes bundled with them. 
It is simple enough to just create a bean that returns a bcrypt password encoder that uses ten rounds of encryption.


\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Java]
@Autowired
public void globalUserDetails(AuthenticationManagerBuilder auth) {
    auth.authenticationProvider(authenticationProvider());
}

@Bean
public DaoAuthenticationProvider authenticationProvider() {
    DaoAuthenticationProvider provider=new DaoAuthenticationProvider();
    provider.setUserDetailsService(userDetailsService);
    provider.setPasswordEncoder(passwordEncoder());
    return provider;
}       

@Bean
public BCryptPasswordEncoder passwordEncoder(){
    return new BCryptPasswordEncoder(10);
}
    \end{lstlisting}
    \caption{Setting the authentication provider in WebSecurityConfigurerAdapter}
    \label{settingauthprovider}
\end{figure}

The UserDetailsService is a Spring Security interface that will allow for a custom implementation of loading users from a type of data store.
In this case, the database created will be used.
To allow the \textit{loadUserByUsername} method to work, a Spring UserDetails object needs to be returned which is a wrapper class for
existing implementations for storing user details.
User roles can also be specified under a GrantedAuthority collection which ensures that only a user with the correct role is able to 
access particular resources.
Restricting access based on the associated role what determines if a user is \textit{authorised} to access the corresponding resource.

\clearpage
\begin{figure}[ht]
    \centering
    \begin{lstlisting}
@Service
public class CustomUserDetailsService implements UserDetailsService {
    private UserRepository userRepo;
    @Autowired
    public CustomUserDetailsService(UserRepository userRepo) {
        this.userRepo = userRepo;
    }
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<Users> user = userRepo.findByUsername(username);
        if(!user.isPresent())
            throw new UsernameNotFoundException("User with username " + username + " not found.");
        return new CustomUserDetails(user.get());
    }
}
    \end{lstlisting}
    \caption{Implemented user details service for finding and loading users}
    \label{userdetailsservice}
\end{figure}

\begin{figure}[ht]
    \centering
    \begin{lstlisting}
public class CustomUserDetails implements UserDetails {
    private final String username;
    private final String password;
    private final boolean isActive;
    private final Collection<? extends GrantedAuthority> authorities;

    public CustomUserDetails(Users user) {
        this.username = user.getUsername();
        this.password = user.getPassword();
        this.isActive = user.isActive();
        this.authorities = AuthorityUtils.createAuthorityList("ROLE_USER");
    }
    ...
}
    \end{lstlisting}
    \caption{CustomUserDetails implementation}
    \label{userdetailswrapper}
\end{figure}


\subsubsection{Oauth2 Authorisation server configuration}
The authorization server is responsible for issuing access tokens to the client after successfully authenticating the resource owner (end user)
and obtaining authorization \cite{hardt2012oauth}.
Just like with the previous sections, Spring Security provides the necessary packages to create a Spring configuration for the authorization
server.
A visual representation of what the sequence of events are with oauth based requests can be seen in figure \ref{oauthgrantflow}.
Credentials are required to be provided by the resource owner (end user in this case) to the client which is then passed onto the authorization
server.
The server will then carry out authentication, based on the credentials provided, and provide an access token if they were valid.
Secured resources can then be accessed using the issued token.

\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=400px]{images/oauth_grant_flow.png}
    \caption{Sequence diagram of the steps involved with accessing secured resources}
    \label{oauthgrantflow}
\end{figure}

Authorization servers can be set up to only allow requests from trusted clients.
This means that two sets of credentials can be provided by a client request for the authorization process.
Clients in possession of a client password can use the HTTP Basic authentication scheme.
For HTTP Basic, the client id and secret will need to be in format of \textit{client-id:client-secret} and then be encoded in the
base64 format. The encoded string value will be included in the header of the request in the following form: 

\begin{verbatim}
    Authorization: Basic Y2xpZW50LWlkOmNsaWVudC1zZWNyZXQ=
\end{verbatim}

The implemented configuration uses in-memory client details as only one client has been implemented.
As shown in figure \ref{authorizationconfigsnippet}, client details can allow for specific roles and scopes to be defined.
Roles and scopes will restrict the type of access a client, providing these credentials, is able to make.
Read and write permissions will be required as the client application will provide a survey management and response functionalities.
Tokens issued to the defined client can expire after a set time, in the example blow this is after 100 seconds.
There was no specific reason to why a value of 100 was chosen, this is really up to the developer of they think is best.
Once the token has expired, a new one will need to be requested from the authorization server.

Refresh tokens can also be issues alongside the regular access token, to the client, and are used to obtain a new access token when 
the current one becomes invalid or expired. 
The validity of the refresh token will therefore need to last longer than the access token.
In this case a value of 200 seconds was used. 

One of the design choices was to use Json Web Tokens (JWT) over normal session based tokens.
%The main reasons behind this decision was the desire to create an Android application as a part of the overall software solution.
Rather than dealing with cookies and sessions, it is much simpler to just store and use a JWT when making requests.
For the authorization server to issue JWTs, a custom TokenStore object needs to be provided.
In this case a new JwtTokenStore is created that applies the custom JwtAccessTokenConverter.
The access token converter allows for a token secret to be specified which is a simple way to sign tokens that are issues.
An alternative, that is more secure, to this would be use a RSA public/private key pair but was not used due to time constraints.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}
@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {
    ...
    @Override
    public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {
        oauthServer
                .tokenKeyAccess("permitAll()")
                .checkTokenAccess("isAuthenticated()");
    }
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients
                .inMemory()
                .withClient("first-client")
                .secret(passwordEncoder.encode("client-secret"))
                .authorizedGrantTypes("password", "authorization_code", "refresh_token")
                .authorities("ROLE_CLIENT", "ROLE_TRUSTED_CLIENT")
                .scopes("read", "write", "trust")
                .accessTokenValiditySeconds(100)
                .refreshTokenValiditySeconds(200);
    }
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {
        endpoints.tokenStore(tokenStore())
                .accessTokenConverter(accessTokenConverter())
                .authenticationManager(authManager);
    }
    @Bean
    public TokenStore tokenStore() {
        return new JwtTokenStore(accessTokenConverter());
    }
    @Bean
    public JwtAccessTokenConverter accessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey("token-secret");
        return converter;
    }
}
    \end{lstlisting}
    \caption{Authorization server configuration code snippet}
    \label{authorizationconfigsnippet}
\end{figure}


\clearpage
\subsubsection{Oauth2 Resource server configuration} \label{oauthresourcesection}
The resource server handles authenticated requests after the application has obtained an access token \cite{oauth2016resourceserver}.
This means that an access token is required before attempting to access resources on the server.
Figure \ref{resourceserverconfig} is the Spring Security configuration used to enable the use of the resource server and dictate which 
API endpoints need authentication.
The implementation ensures all endpoints that are come under the \textit{/api/} parent path require valid authentication to be accessed.
If some exception occurs with checking authentication, a general OAuth2AccessDeniedHandler exception is thrown; being represented in the
response body.
Normally the resource id specified can be used to ensure that an issued token allows access to a particular resource.
It can also be used to ensure the correct version of the API is being used to access resources on the server.


\begin{figure}[ht]
    \centering
    \begin{lstlisting}
@Configuration
@EnableResourceServer
public class ResourceServerConfig extends ResourceServerConfigurerAdapter {
    private static final String RESOURCE_ID = "resource_id";

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) {
        resources.resourceId(RESOURCE_ID).stateless(true);
    }
    @Override
    public void configure(HttpSecurity http) throws Exception {
        http
                .anonymous().disable()
                .authorizeRequests()
                .antMatchers("/api/**").authenticated()
                .and().exceptionHandling().accessDeniedHandler(new OAuth2AccessDeniedHandler());
    } 
}
    \end{lstlisting}
    \caption{Resource server configuration}
    \label{resourceserverconfig}
\end{figure}



\clearpage
\subsection{REACT client}
%Talk about everything to do with the implementation of the REST client
%State how you started off from that OKTA example and worked from there. 
As mentioned in the solution approach (section \ref{chosenclientside}), REACT is going to be used to create an interactive client
side application.
To understand what this client application needs to do, it is worthwhile to create a break down of what will be needed by the 
font-end client by referring back to figure \ref{proposedsystemmodel} outlining how the system is going to be used.
From that diagram, the main aims are to: 

\begin{itemize}
    \tightlist
    \item Be able to log in using registered user credentials.
    \item Have access to different resources based on the user role.
    \begin{itemize}
        \item \textit{Expert} role for creating and publishing surveys.
        \item \textit{Student} role for viewing available surveys and respond to them.
    \end{itemize}
    \item Be usable on Android devices, ideally as a native application.
\end{itemize}

\subsubsection{Client class diagram}
\begin{figure}[ht]
    \centering
    \includegraphics[width=300px]{images/client_architecture.png}
    \caption{UML diagram representing the client architecture}
    \label{clientarch}
\end{figure}

\noindent
Figure \ref{clientarch} is an overview of the current implementation for the client.
Rather than a set of associations between components, there are dependencies.
This is because each component does not %TODO

\subsubsection{REACT Component}
Components are fundamental to a REACT application as they act as the main building block.
These components that are created can have multiple levels of child components based on what is required.
As REACT is just a library, there is no strict framework to adhere to like with the Java Spring application.
This leads to a lot more flexibility and simplicity for the implementation.
Many parts of this project will revolve around explaining implementations of the components for th client so it makes sense to cover
some fundamentals as context before continuing on.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Javascript]
class Welcome extends React.Component {
    constructor(props) {
    super(props);
    this.state = { name: "Foo" };
    this.handleClick = this.handleClick.bind(this);
    }
    
    render() {
    return (
        <div>
            <h1>Hello, {this.props.name}</h1>
            <ExampleClass prop1={"foo"}/>
        </div>
    );
  }
}
    \end{lstlisting}
    \caption{Basic component}   
    \label{basiccomponent}
\end{figure}

Figure \ref{basiccomponent} is the basic outline of what makes a REACT component.
The \textit{render} method is the main aspect that makes components as powerful as they are as they cause the component to re-render 
if its state has been changed.
JSX is the type of content to be returned by the method.
It is similar to HTML in that tags are used to represent elements however the main difference is that you can explicitly use class
names as the tag type. This is the way REACT works for rendering other components.
This JSX is compiled, using Babel, into regular HTML and JavaScript for runtime purposes.
A \textit{render} method is the only one that is explicitly required when implementing a component class.
The \textit{state} is composed of the class specific values that can dictate what values and what behaviour is presented.
The state, of a component, can have initial values set through an included constructor.


\subsubsection{Authentication service}
To be able to make requests, a service will need to be created to handle obtaining and storing access tokens.
Validation will also need to be done against the token when required to ensure that it is still valid.
Further validation against the actual server can also be done as a further measure to be sure.
This authentication service is written in pure JavaScript and simply provides static methods.
The static nature of the methods means that they can be used without having to instantiate an object of the service class.

\subsubsection*{Token retrieval}

\begin{figure}[ht]
    \centering
    \begin{lstlisting}
static async getToken(username, password) {
    console.log("Requesting token...");
    let path = `/oauth/token?grant_type=password&username=${username}&password=${password}`;
    const response = await fetch(path, this.request)
      .then(response => {
        return response.json();
      })
      .catch(error => {
        console.error("Error while fetching token...");
        console.error(error);
      });
    localStorage.setItem("accessToken", response.access_token);
    localStorage.setItem("refreshToken", response.refresh_token);
    localStorage.setItem("bearer", "Bearer " + response.access_token);
    return response.access_token;
}
    \end{lstlisting}
    \caption{getToken method}
    \label{gettokenmethod}
\end{figure}

As mentioned in section \ref{oauthresourcesection}, a valid token is required to access restricted resources.
Rather than repeating similar lines of code in every code block that requires the token, it made sense to create this method that will
retrieve a token using valid resource owner credentials.
If the fields \textit{access\_token} and \textit{refresh\_token} are found in the response body, they will be stored to localStorage.
Having these values in localStorage means that the values can be requested in any other part of the project.
For convenience sake, a bearer value is also saved to localStorage as it combines the keyword \textit{Bearer} with the token value.
Requests made with the bearer token will be sent as the following key value pair in the header:

\begin{verbatim}
    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
    eyJleHAiOjE1NTMwODg0ODIsInVzZXJfbmFtZSI6InRlc3QiLCJhdXRob3J
    pdGllcyI6WyJST0xFX1VTRVIiXSwianRpIjoiMTU0MTRiOTgtYzEzNy00Yz
    k1LWFjNWEtNDIxYWE4YWMxMGI2IiwiY2xpZW50X2lkIjoiZmlyc3QtY2xpZ
    W50Iiwic2NvcGUiOlsicmVhZCIsIndyaXRlIiwidHJ1c3QiXX0.Hh3ge1BY
    gvyUw2Bz3PmnRwDm9nXoXny2ccOs6oMVI54
\end{verbatim}


\subsubsection*{Simple token validation}
Payloads in Json Web Tokens include an expiry time represented in umber of milliseconds since midnight Jan 1 1970.
When trying to access new resources, it makes sense to ensure that the token has not expired yet.
If it has, then the user can either be redirected back to the login page or take advantage of the refresh token.
The \textit{checkTokenExpire} method decodes and checks if the token has expired based on the current system time.
A boolean value is then returned to indicate if it is still valid or not.

% \begin{figure}[ht]
%     \centering
%     \begin{lstlisting}
% const { exp } = decode(refreshToken);
% if (exp < new Date().getTime() / 1000) {
%   console.error("Expired token...");
%   return false;        
% }
%     \end{lstlisting}
%     \caption{Snippet from \textit{checkTokenExpired} method checking if the current token has expired or not}
%     \label{checktokenexpired}
% \end{figure}
\clearpage
\subsubsection{Survey manager}
One of the main components to implement will be the survey editor as without it new surveys cannot be added to the database.
Referring back to figure \ref{proposedsystemmodel}, an \textit{expert} will need to manage surveys.
Survey management breaks down into a five different types of functionality which are:

\begin{itemize}
    \tightlist
    \item Viewing a list of existing surveys 
    \item Adding a new survey
    \item Editing an existing survey
    \item Deleting an existing survey
    \item Viewing survey response statistics
\end{itemize}

From the breakdown of what is needed by the survey editor, it introduces a lot more complexity that was initially thought.
Though the API can support such functionality, it is much more challenging to write front end code that can take advantage of it.


\begin{figure}[ht]
    \centering
    \includegraphics[width=400px]{images/survey_manager_screen.png}
    \caption{Survey editor page}
    \label{surveyeditorpage}
\end{figure}

The main REACT component for managing surveys is called the SurveyList.
This component renders a page that lists out all of the surveys that exist as a table, displaying the survey name alongside its 
description.
Buttons are presented alongside each entry, allowing a user to either edit or delete that specific survey.
To add a new survey, 
A button for creating a new survey is also available at the top right of the page.

\subsubsection*{Viewing surveys}

The simplest feature for the editor is the ability to view a list of surveys that already exist.
A request against the \textit{/api/surveys} endpoint can be made to retrieve a list of all the surveys that currently populate
the database.
The API will return the list in JSON form, which can then be consumed by the REACT component using a mounting method.
A mounting method is executed immediately after it has been inserted into the DOM tree and is used if resources need to be obtained
from a remote endpoint.
Due to the nature of JavaScript, to prevent blocking from occurring, this method is executed asynchronously.
Figure \ref{serverlistcomponentmount} shows how such behaviour is implemented into a REACT component. 

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Javascript, escapechar=|]
async componentDidMount() {
    console.log("Getting survey list...");
    this.setState({isLoading: true});
    let request = {
        method: 'GET',
        headers: {'Authorization': localStorage.getItem('bearer')},
    };
    console.log(request);
    let response = await fetch('api/surveys', request)
        .then(response => {
            return response.json();
        })
        .then(data => this.setState({surveys: data, isLoading: false})); |\label{setsurveylistdata}|
}
    \end{lstlisting}
    \caption{ComponentDidMount method for loading the list of surveys}
    \label{serverlistcomponentmount}
\end{figure}

Line \ref{setsurveylistdata}, in figure \ref{serverlistcomponentmount}, is the operation which stores the JSON data into the component's state.
The change to the state will cause the component to trigger the render method again with the updated values.
Survey values are stored as a JSON array which can be iterated through.
For rendering purposes, a mapping method can be called to create the required JSX for each entry in the table.
The mapped values can then be rendered by referencing the const value, surrounded by brackets, in the return body.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=JavaScript, escapechar=|]
const surveyList = surveys.map(survey => {
    return <tr key={survey.id}>
        <td style={{whiteSpace: 'nowrap'}}>{survey.name}</td>
        <td>{survey.description}</td>
        <td>
            <ButtonGroup>
                <Button size="sm" color="primary" tag={Link} to={"/surveys/" + survey.id}><MdEdit/></Button>
                <Button size="sm" color="danger" onClick={() => this.remove(survey.id)}><MdDelete/></Button>
            </ButtonGroup>
        </td>
    </tr>
});
    \end{lstlisting}
    \caption{Mapping survey data into individual table row entries}
    \label{surveylistmapping}
\end{figure}  


\subsubsection*{Adding new surveys}
Clicking on the button to add a new survey will redirect the user to a page with empty fields for both the survey name and description.
This page allows for the necessary JSON to be created to send in a HTTP POST request to the \textit{/api/surveys} endpoint.
Submitting the survey will call an event handler for preparing and sending the request against to the survey.

% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=400px]{images/add_survey_screen.png}
%     \caption{Add survey page}
%     \label{addsurveypage}
% \end{figure}


\subsubsection*{Editing an existing survey}
A design choice was made to extend the functionalities of what was implemented for adding new surveys so that it can also edit them.
This required a lot more code to be implemented as it needed to support the following features to be a competent survey editor:
\begin{itemize}
    \tightlist
    \item Add new questions
    \item Edit existing questions
    \item Remove existing questions 
    \item Add new question choices 
    \item Edit existing question choices
    \item Remove existing question choices
\end{itemize}

Referring back to figure \ref{clientarch}, the survey edit function is built of many more REACT components compared to others.
In order to get the functionality that is required, a SurveyQuestionList component was created to allow survey details to be changed 
and handle the rendering of many SurveyQuestionView components.
Each SurveyQuestionView component is responsible for rendering the question name with all the choices that have been added to it.
They also present options, to the user, for editing or deleting the question.

\begin{figure}[ht]
    \centering
    \includegraphics[width=400px]{images/edit_survey_screen.png}
    \caption{Edit survey example page}
    \label{editsurveyexample}
\end{figure}

Deleting a question is trivial as only a HTTP DELETE request against \textit{/api/surveys/{surveyId}/questions/{questionId}} needs to be done.
Editing is a lot more involved as every aspect of a question needs to be editable by the user.
This not only includes the actual question title itself, but each individual choice that is associated with it.
This is where the SurveyQuestionEdit component becomes relevant.
The SurveyQuestionEdit component is rendered as a dialogue box and is an all-in-one type interface for users to edit all aspects of 
a question. 
Adding a new question also uses the same component as the functionality required will be the same; it is just initialised
with null values.

\begin{figure}[ht]
    \centering
    \includegraphics[width=400px]{images/edit_question_screen.png}
    \caption{Edit question example}
    \label{editquestionexample}
\end{figure}

\subsubsection*{Delete an existing survey}

Similar to how deleting a question is trivial, this statement also applied to surveys.
All that is required to delete a survey is to submit a HTTP DELETE request to the \textit{/api/surveys/{surveyId}} endpoint.
Thanks to cascading options that are enabled in the Java Spring application, any children (questions and question choices) will also
get deleted.
Deleting is also set to be transactional, ensuring that the operation completes appropriately otherwise the operation will be cancelled
and any will be rolled back.
