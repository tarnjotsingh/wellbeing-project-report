\clearpage
\section{Design and Implementation}

At this point the project has a set of requirements to meet and basic solution approach has been outlined for each aspect of 
the project.
This section aims to inform the reader of the detailed design choices made and how this was implemented to achieve the final product.

\subsection{System model design} \label{system model design}

\begin{figure}[ht]
    \includegraphics[width=450px]{images/system_model.png}
    \caption{Proposed system model}
\end{figure}


The proposed system model outlines the method in which an \textit{expert} can create, edit or delete a survey and how this can be 
fed to a student.
The main functionality to point out, that really links the two user types together, is how new survey send some sort notification 
to a (potentially) subscribed student; leading them to respond to the survey.
From the diagram, the reader should be able to see how a student will be able to either view surveys at their own will or be prompted
by a notification that had been sent out by some service.
The system outlines that there are really only two different categories of user that will use the system, this makes sense when looking
back at the articulation of the problem and the original brief given.

\clearpage
\subsection{Flow diagram}

An important process for the software solution is to be able to add and modify surveys for students to respond to.
The system model design does not go into much detail about this part of the system so it will be important to gain some clarity around this area.
Below is the proposed process flow diagram for what will occur when a user, of the system, attempts to add a new survey.
It outlines the need for authorisation (have permission to access such a resource) before carrying out two steps of validation of the
data provided.
If validation passes, then the survey and survey questions entries will be added to the database.
As mentioned in the system model design, there is a mention of the notification service that will alert students about a new survey they
can participate in.
The flow diagram shows how an expert can be prompted about sending out an alert to students, after submitting the survey.
That is where the system will then move onto executing the notification service, or just conclude the current process flow.

\begin{figure}[ht]
    \centering
    \includegraphics[width=150px]{images/flow_diagram.png}
    \caption{Flow diagram of the processes involved when an \textit{expert} adds a new survey}
\end{figure}

\clearpage

\subsection{Database (data layer)}
The database is important to get right as the design needs to store surveys data in a logical structured manner.
To understand what is required for the database, it makes sense to first break it down and understand relationships between
each entity.

\begin{enumerate}
    \item Each \textit{survey} will have a survey name or title and has a \textit{one-to-many} relationship with \textit{survey questions}.
    \item Each \textit{survey question} will have a question name and will have a \textit{one-to-many} relationship with \textit{question choices}.
    \item Each \textit{question choice} will have a choice name with an associated weight.
    \item To store user choices for a \textit{survey question} a \textit{user question choice} entity can be used.
        \begin{enumerate}
            \item Each \textit{user question choice} will have a \textit{many-to-one} relationship with a \textit{survey question} and \textit{question choice}
        \end{enumerate}
\end{enumerate}

To map out these relationships, into a diagram that can be visually understood, JDL (JHipster Domain Language) was used.
The JDL approach allows for a more logical approach of designing a database since it avoids any confusion from a purely visual approach.
Below is the JDL written with the associated diagram representation.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=JDL]
entity UserQuestionChoice {
	timeStamp Timestamp
}
entity Choice {
	choice String,
    weight Integer
}
entity Question {
	question String
}
entity Survey {
	description String
}
relationship OneToMany {
    Survey{survey} to Question{survey}
	Question{question} to Choice
}
relationship ManyToOne {
    UserQuestionChoice to Question
    UserQuestionChoice to Choice
}
    \end{lstlisting}
    \caption{JDL based on the breakdown of what will be needed to store surveys}
\end{figure}

\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=250px]{images/jhipster-jdl.png}
    \caption{Graph produced by JDL-studio}
    \label{survey-jdl-graph}
\end{figure}

Since initial prototyping is being done using the JHipster framework, it makes sense to take advantage of tools such as 
JDL-studio to produce diagrams such as \ref{survey-jdl-graph}.
To fully take advantage of the JDL written, it can be imported into the JHipster product being worked on. 
The functionality of value that will be desired from the import process will be a set of generated classes that represent
the database schema.

\subsubsection{Java Persistence API}
An SQL database schema can be created in Java itself with the help of Hibernate. % You might want to go over this in the lit review.
Hibernate will facilitate the mapping of object-orientated domains, created in Java, to the corresponding tables in a relational database.
The Java Persistence API (JPA) set of packages will provide the necessary annotations to correctly set up classes that represent \textit{tables}.
Figure \ref{question object} shows how a class, with all the required annotations, can be created.
Domain classes that are created, as a part of the Java code, use the Java Persistence API (JPA) set of packages.
The JPA packages provide the required annotations to be used in a class to allow a chosen mapping tool (Hibernate in this case) to understand how
to map class objects into database tables.
Cascading options are also available to allow actions on an entry in the table to be reflected on any child entities.
In the example below, cascading is used to ensure that if a \textit{question} is removed from the database, any \textit{question choices} associated
with it are also removed; ensuring no orphan entries are produced in the database.

\clearpage
\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Java]
@Entity
@Table(name = "question")
public class Question implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(name = "question")
    private String question;
    @OneToMany(mappedBy = "question", cascade = CascadeType.ALL)
    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
    private Set<Choice> questionChoices = new HashSet<>();
    @ManyToOne(fetch = FetchType.EAGER, optional = false)
    @JoinColumn(name = "survey_id", nullable = false)
    @JsonIgnore
    private Survey survey;
    @OneToMany(mappedBy = "question", cascade = CascadeType.ALL)
    private Set<UserQuestionChoice> userQuestionChoices = new HashSet<>();
    \end{lstlisting}
    \caption{Question object to be mapped to a database table}
    \label{question object}
\end{figure}


The benefit of this approach is that the database schema can be controlled programatically and also allows for repository interfaces to be created.
Repository interfaces is what is used to invoke actions against the corresponding table in the database.
A notable feature of these interfaces is that they allow for \textit{derived} methods to be written without having to write any logic for it.
The idea behind these derived methods is that it gives flexibility to the developer to incorporate query methods to a specific problem.
It is also important to note that there is no SQL being written as a part of the code; only Java code is being written.


\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Java]
@Repository
public interface QuestionRepository extends JpaRepository<Question,Long> 
{
    List<Question> findBySurveyId(Long surveyId);
    Optional<Question> findByIdAndSurveyId(Long id, Long surveyId);
    boolean existsByIdAndSurveyId(Long id, Long surveyId);

    @Transactional
    @Modifying
    void deleteByIdAndSurveyId(Long id, Long surveyId);
}
    \end{lstlisting}
    \caption{Repository interface for Question domain/table}
    \label{repo example}
\end{figure}


Now that the main Java components have been covered, Spring will need to be configured to actually connect to a database.
For this project, a MySQL container will be configured. To do this, a \textit{docker compose} file can be created.
As shown in figure \ref{sqldocker}, the file allows for environment variables and exposed ports to be specified.
Once the file is ready, the command \textit{docker-compose up compose.yml} can be run.
This command will pull down the docker image and automatically start it along with applying the specified options in the file.
After logs start appearing in the command-line, a connection attempt to the database can be made using a tool such as MySQLWorkbench.
Using a tool such as MySQLWorkbench is important as it allows for manual SQL queries to be run against the database and verify that operations
executed by hibernate are doing the right thing.


\begin{figure}[ht]
    \centering
    \begin{lstlisting}
#compose version of 3.3        
version: '3.3'
services:
  db:
    image: mysql
    restart: always
    environment:
      MYSQL_DATABASE: 'springdb'
      MYSQL_USER: 'admin'
      MYSQL_PASSWORD: 'admin'
      MYSQL_ROOT_PASSWORD: 'password'
      lower_case_table_names: '1'
      character_set_server: 'utf8'
    ports:
      # <Port exposed> : < MySQL Port running inside container>
      - '3306:3306'
    expose:
      # Opens port 3306 on the container
      - '3306'           
    \end{lstlisting}
    \caption{Docker compose yaml file for a mysql image from dockerhub}
    \label{sqldocker}
\end{figure}

Spring still needs to be configured to actually connect to this database running in a container.
The details required will be the database name with valid login credentials.
An application.yml (yaml file) is used by spring to configure various aspects of the project, depending on what is required by the developer.
Below, in figure \ref{springymldbconfig}, the reader can see the simple configuration needed to get a database connection set up.
The SpringBoot application will automatically read and apply the configuration on the initial start up; if anything is wrong with the config,
and exception will be thrown and stop the server.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[escapechar=|]
spring:
    datasource:
        url: jdbc:mysql://localhost:3306/springdb
        driver-class-name: com.mysql.cj.jdbc.Driver
        username: root
        password: password
    jpa:
        database: mysql
        show-sql: true
        hibernate:
            ddl-auto: update |\label{hibernate option}|
    \end{lstlisting}
    \caption{Snippet from application.yml for configuring the spring project}
    \label{springymldbconfig}
\end{figure}

\clearpage
\subsubsection{Final DB schema}

\begin{figure}[ht]
    \centering
    \includegraphics[width=300px]{images/db_schema.png}
    \caption{Database schema diagram produced from MySQLWorkbench}
    \label{sqldbschamfull}
\end{figure}

Once everything has been correctly configured, the SpringBoot application can be run.
Line \ref{hibernate option}, in figure \ref{springymldbconfig} be set to either \textit{create} or \textit{update}.
The main difference between the two is that \textit{create} will always overwrite any existing schema whereas \textit{update} will not.



\subsection{REST API}
% Talk about how it is going to be used
% Outline the main endpoints that need to be implemented
% Detail the endpoints that have been implemented and what they do

The REST API, to be implemented, is going to be a very important part of this project as it will be means of communicating between
the server and client. 
As mentioned in section \ref{restliterature}, a set of URL based endpoints will need to be defined as a part of the API 
documentation.
The URL paths themselves will be based on the type of access needed to resources of the system, most notably survey and user data.
Since this is an application that focuses on creating and responding to surveys, the API defined will have to focus on that.
The REST endpoints will be based on the system model diagram in section \ref{system model design} as it outlines the use cases 
of the system.

\subsubsection{API Design}
Designing the API will heavily revolve around the database schema as shown in figure \ref{sqldbschamfull}.
For this project, Swagger2 (OpenAPI2) will be used to define the API and produce the necessary API documentation.
This section will just cover all the of API paths that have been implemented with a basic description for each; full 
API documentation is available in the appendix.

\subsubsection*{Surveys resource}
Resource path: /api/surveys

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get all surveys as a list \\
      \textbullet~ POST & Create a new survey \\
      \textbullet~ PUT & Update an existing survey \\
    \end{tabular}
\end{listliketab}

\noindent
Resource path: /api/surveys/\{id\}

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get a survey with a given ID. \\
      \textbullet~ DELETE & Delete a survey with a given ID. \\
    \end{tabular}
\end{listliketab}

\subsubsection*{Questions resource}
Resource path: /api/surveys/\{surveyId\}/questions

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get all questions for a given survey with specified ID as a list. \\
      \textbullet~ POST & Create a new question for survey with specified \\
      \textbullet~ PUT & Update an existing question in a given survey with specified ID.
    \end{tabular}
\end{listliketab}


\noindent
Resource path: /api/surveys/\{surveyId\}/question/\{questionId\}

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get a specified question for a specified survey. \\
      \textbullet~ DELETE & Delete a specified question for a specified survey. \\ 
    \end{tabular}
\end{listliketab}


\subsubsection*{Choices resource}

Resource path: /api/surveys/\{surveyId\}/question/\{questionId\}/choices

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get all choices for a specified question for a specified survey. \\
      \textbullet~ POST & Create a new choice for a specified question for a specified survey. \\ 
      \textbullet~ PUT & Update an existing choice for a specified question for a specified survey.
    \end{tabular}
\end{listliketab}

\noindent
Resource path: /api/surveys/\{surveyId\}/question/\{questionId\}/choices/\{choiceId\}

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get a specified choice for a specified question for a specified survey. \\
      \textbullet~ DELETE & Delete a specified choice for a specified question for a specified survey. \\ 
    \end{tabular}
\end{listliketab}

\subsubsection*{User resource}

Resource path: /api/users

\begin{listliketab}
    \begin{tabular}{lp{11cm}}
      \textbullet~ GET & Get all users as a list. \\
      \textbullet~ POST & Create/Register a new user. \\ 
      \textbullet~ PUT & Update user information.\\
    \end{tabular}
\end{listliketab}

\clearpage
\subsubsection{Java implementation}

In REST, access to resources are controlled by REST controllers.
These controller classes therefore need to be implemented.
Spring comes with a set of annotations that be used to mark certain classes as REST controller.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Java, escapechar=|]
@RestController
@RequestMapping("/api")
public class QuestionResource {
    private final Logger log = LoggerFactory.getLogger(QuestionResource.class);
    private static final String ENTITY_NAME = "question";
    private final SurveyRepository surveyRepository;
    private final QuestionRepository questionRepository;

    @Autowired
    public QuestionResource(QuestionRepository questionRepository, SurveyRepository surveyRepository) {
        this.questionRepository = questionRepository;
        this.surveyRepository = surveyRepository;
    }
    ...
    @PostMapping("/surveys/{surveyId}/questions")
    public ResponseEntity<Question> createQuestionForSurvey(@PathVariable (value = "surveyId") Long surveyId, @RequestBody Question question) throws URISyntaxException {
        log.debug("REST request to save Question : {} in survey : {}", question, surveyId);
        if (question.getId() != null) {
            throw new BadRequestAlertException("A new question cannot already have an ID", ENTITY_NAME, "idexists");
        }
        Question toReturn = surveyRepository.findById(surveyId).map(survey -> {     |\label{repousage}|
            question.setSurvey(survey);
            return questionRepository.save(question);
        }).orElseThrow( () -> new ResourceNotFoundException("Survey with ID " + surveyId + " not found."));

        return ResponseEntity.created(new URI("/api/surveys/" + surveyId + "/questions/" + toReturn.getId()))
                .headers(HeaderUtil.createEntityCreationAlert(ENTITY_NAME, toReturn.getId().toString()))
                .body(toReturn);
    }
    ...      
    \end{lstlisting}
    \caption{REST controller snippet for question resource}
    \label{restcontrollerexample}
\end{figure}

The code shown in figure \ref{restcontrollerexample} is a snippet of code that is used in the REST controller for managing access to the question resouce.
For the sake of simplicity, all the code was done under each of the mapping methods in the class.
What you may see, in more flushed out examples, is that a lot of the functionality is reserved to REST service classes that can be used in the controllers.

Tags such as \textit{@PostMapping} allows an API endpoint to be defined with the HTTP request type.
The return type of the method is what will be returned in the body of the response of the request.
If an error is encountered while trying to process the request, the appropriate error will be thrown and result in the associated response (such as 404 Not Found).
This process is repeated for all the different endpoints that need to be implemented.
Depending on the type of HTTP request, the underlying logic will obviously be different. 
Line \ref{repousage} in figure \ref{restcontrollerexample} also demonstrates how queries to the underlying database can be made through the appropriate
repository interface.

\subsubsection{Swagger documentation}
Swagger2 (OpenAPI2) is enabled for this project so swagger related endpoints are available.
The most notable (and useful) endpoint provided is \textit{/swagger-ui.html} as it provides an interactive API documentation page.
Other packages that are brought into the project, such as Spring Security, also provide a set of endpoints. 
Using the swagger ui, these hidden endpoints are also exposed.
Each of the endpoints listed can be expanded to show the type of body is accepted as a part of the request and lists all the potential 
returns types and what to expect in the response body for each of them.

\begin{figure}[ht]
    \centering
    \includegraphics[width=250px]{images/swagger-ui.png}
    \caption{View of the swagger ui from the browser}
    \label{swaggerui}
\end{figure}

\clearpage
\subsection{Spring Security}

Restrictions needs to be made to who can access the API, particularly with endpoints related to accessing user data.
To secure these endpoints, Spring Security using Oauth2 with Json Web Tokens will be used to authenticate and authorise users.

% - Web security configuration
% - Authorization server

% In order to do this, there are three impor


\subsubsection{Web security configuration}
The first part to get security implemented into the Java Spring project is to configure the \textit{WebSecurityConfigurerAdapter}.
This adapter, that is extended, allows customisations to both WebSecurity and HttpSecurity.
The adapter class and the \textit{@EnableWebSecurity} annotation work together to provide web based security \cite{winch2013springsecurity}.
Really basic authentication can be achieved by defining in-memory credentials which can be used with HTTP basic auth.

Basic auth is not going to be secure enough for any modern system and credentials need to be stored in a database; not in memory.
In order to get user details to be stored in the database, a custom authentication provider will need to be created.
A DaoAuthenticationProvider object will need to be created and given to the authentication provider method.
The authentication provider needs to have a Spring user details service and a password encoder to be specified.
Specifying the password encoder is trivial as Spring Security comes bundled with them. 
It is simple enough to just create a bean that returns a bcrypt password encoder that uses ten rounds of encryption.


\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=Java]
@Autowired
public void globalUserDetails(AuthenticationManagerBuilder auth) {
    auth.authenticationProvider(authenticationProvider());
}

@Bean
public DaoAuthenticationProvider authenticationProvider() {
    DaoAuthenticationProvider provider=new DaoAuthenticationProvider();
    provider.setUserDetailsService(userDetailsService);
    provider.setPasswordEncoder(passwordEncoder());
    return provider;
}       

@Bean
public BCryptPasswordEncoder passwordEncoder(){
    return new BCryptPasswordEncoder(10);
}
    \end{lstlisting}
    \caption{Setting the authentication provider in WebSecurityConfigurerAdapter}
    \label{settingauthprovider}
\end{figure}

The UserDetailsService is a Spring Security interface that will allow for a custom implementation of loading users from a type of data store.
In this case, the database created will be used.
To allow the \textit{loadUserByUsername} method to work, a Spring UserDetails object needs to be returned which is a wrapper class for
existing implementations for storing user details.
User roles can also be specified under a GrantedAuthority collection which ensures that only a user with the correct role is able to 
access particular resources.
Restricting access based on the associated role what determines if a user is \textit{authorised} to access the corresponding resource.

\clearpage
\begin{figure}[ht]
    \centering
    \begin{lstlisting}
@Service
public class CustomUserDetailsService implements UserDetailsService {
    private UserRepository userRepo;
    @Autowired
    public CustomUserDetailsService(UserRepository userRepo) {
        this.userRepo = userRepo;
    }
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<Users> user = userRepo.findByUsername(username);
        if(!user.isPresent())
            throw new UsernameNotFoundException("User with username " + username + " not found.");
        return new CustomUserDetails(user.get());
    }
}
    \end{lstlisting}
    \caption{Implemented user details service for finding and loading users}
    \label{userdetailsservice}
\end{figure}

\begin{figure}[ht]
    \centering
    \begin{lstlisting}
public class CustomUserDetails implements UserDetails {
    private final String username;
    private final String password;
    private final boolean isActive;
    private final Collection<? extends GrantedAuthority> authorities;

    public CustomUserDetails(Users user) {
        this.username = user.getUsername();
        this.password = user.getPassword();
        this.isActive = user.isActive();
        this.authorities = AuthorityUtils.createAuthorityList("ROLE_USER");
    }
    ...
    \end{lstlisting}
    \caption{CustomUserDetails implementation}
    \label{userdetailswrapper}
\end{figure}


\subsubsection{Oauth2 Authorisation server configuration}
The authorization server is responsible for issuing access tokens to the client after successfully authenticating the resource owner (end user)
and obtaining authorization \cite{hardt2012oauth}.
Just like with the previous sections, Spring Security provides the necessary packages to create a Spring configuration for the authorization
server.
A visual representation of what the sequence of events are with oauth based requests can be seen in figure \ref{oauthgrantflow}.
Credentials are required to be provided by the resource owner (end user in this case) to the client which is then passed onto the authorization
server.
The server will then carry out authentication, based on the credentials provided, and provide an access token if they were valid.
Secured resources can then be accessed using the issued token.

\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=400px]{images/oauth_grant_flow.png}
    \caption{Sequence diagram of the steps involved with accessing secured resources}
    \label{oauthgrantflow}
\end{figure}

Authorization servers can be set up to only allow requests from trusted clients.
This means that two sets of credentials can be provided by a client request for the authorization process.
Clients in possession of a client password can use the HTTP Basic authentication scheme.
For HTTP Basic, the client id and secret will need to be in format of \textit{client-id:client-secret} and then be encoded in the
base64 format. The encoded string value will be included in the header of the request in the following form: 

\begin{verbatim}
    Authorization: Basic Y2xpZW50LWlkOmNsaWVudC1zZWNyZXQ=
\end{verbatim}

The implemented configuration uses in-memory client details as only one client has been implemented.
As shown in figure \ref{authorizationconfigsnippet}, client details can allow for specific roles and scopes to be defined.
Roles and scopes will restrict the type of access a client, providing these credentials, is able to make.
Read and write permissions will be required as the client application will provide a survey management and response functionalities.
Tokens issued to the defined client can expire after a set time, in the example blow this is after 100 seconds.
There was no specific reason to why a value of 100 was chosen, this is really up to the developer of they think is best.
Once the token has expired, a new one will need to be requested from the authorization server.

Refresh tokens can also be issues alongside the regular access token, to the client, and are used to obtain a new access token when 
the current one becomes invalid or expired. 
The validity of the refresh token will therefore need to last longer than the access token.
In this case a value of 200 seconds was used. 

One of the design choices was to use Json Web Tokens (JWT) over normal session based tokens.
%The main reasons behind this decision was the desire to create an Android application as a part of the overall software solution.
Rather than dealing with cookies and sessions, it is much simpler to just store and use a JWT when making requests.
For the authorization server to issue JWTs, a custom TokenStore object needs to be provided.
In this case a new JwtTokenStore is created that applies the custom JwtAccessTokenConverter.
The access token converter allows for a token secret to be specified which is a simple way to sign tokens that are issues.
An alternative, that is more secure, to this would be use a RSA public/private key pair but was not used due to time constraints.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}
@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {
    ...
    @Override
    public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {
        oauthServer
                .tokenKeyAccess("permitAll()")
                .checkTokenAccess("isAuthenticated()");
    }
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients
                .inMemory()
                .withClient("first-client")
                .secret(passwordEncoder.encode("client-secret"))
                .authorizedGrantTypes("password", "authorization_code", "refresh_token")
                .authorities("ROLE_CLIENT", "ROLE_TRUSTED_CLIENT")
                .scopes("read", "write", "trust")
                .accessTokenValiditySeconds(100)
                .refreshTokenValiditySeconds(200);
    }
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {
        endpoints.tokenStore(tokenStore())
                .accessTokenConverter(accessTokenConverter())
                .authenticationManager(authManager);
    }
    @Bean
    public TokenStore tokenStore() {
        return new JwtTokenStore(accessTokenConverter());
    }
    @Bean
    public JwtAccessTokenConverter accessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey("token-secret");
        return converter;
    }
}
    \end{lstlisting}
    \caption{Authorization server configuration code snippet}
    \label{authorizationconfigsnippet}
\end{figure}


\clearpage
\subsubsection{Oauth2 Resource server configuration}
The resource server handles authenticated requests after the application has obtained an access token \cite{oauth2016resourceserver}.
This means that an access token is required before attempting to access resources on the server.
Figure \ref{resourceserverconfig} is the Spring Security configuration used to enable the use of the resource server and dictate which 
API endpoints need authentication.
The implementation ensures all endpoints that are come under the \textit{/api/} parent path require valid authentication to be accessed.
If some exception occurs with checking authentication, a general OAuth2AccessDeniedHandler exception is thrown; being represented in the
response body.
Normally the resource id specified can be used to ensure that an issued token allows access to a particular resource.
It can also be used to ensure the correct version of the API is being used to access resources on the server.


\begin{figure}[ht]
    \centering
    \begin{lstlisting}
@Configuration
@EnableResourceServer
public class ResourceServerConfig extends ResourceServerConfigurerAdapter {
    private static final String RESOURCE_ID = "resource_id";

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) {
        resources.resourceId(RESOURCE_ID).stateless(true);
    }
    @Override
    public void configure(HttpSecurity http) throws Exception {
        http
                .anonymous().disable()
                .authorizeRequests()
                .antMatchers("/api/**").authenticated()
                .and().exceptionHandling().accessDeniedHandler(new OAuth2AccessDeniedHandler());
    } 
    \end{lstlisting}
    \caption{Resource server configuration}
    \label{resourceserverconfig}
\end{figure}




\subsection{REACT client}
Talk about everything to do with the implementation of the REST client
State how you started off from that OKTA example and worked from there. 
1