% The solution approach needs to outline the general approach that will be taken for the project
% Specific implementation details should only be outlined and discussed in the design and implementation section.
\section{Solution Approach}
This section aims to cover the general outline of the potential approaches that can be used for this project.
The selected solution approach decides what development method and technologies to use for the project with justifications
for each decision made.
It is vital to take the points covered in the problem statement (section \ref{problemstatement}) and literature 
review (section \ref{litreview}) into account to ensure the best solution approach is taken.

% Go over and discuss some of the different development approaches (waterfall/agile(scrum/kanban)) and decide which one to use
\subsection{Development approach}
Since the author of this paper is the only one developing, it is important to decide on the most appropriate development approach.

\subsubsection*{Waterfall}
Being the oldest, and most mature, software development model it makes sense to cover this one first.
The waterfall model divides the software development life cycle into five distinct and linear stages.
Requirements analysis and definition, system and software design, implementation and unit testing, integration and system testing,
operation and maintenance.
This approach is mostly used when developing large and complex systems; with success to prove its success.
It also allows management teams to have a better understanding where, in the timeline, development is, however, is not flexible enough
to deal with unexpected events.
Once the code has been written, it is unlikely people will have the opportunity to go back and improve on it or address certain flaws.
Initial requirements and design may suggest that the software solution will work, nothing is certain until the implementation has started
Huge costs are involved to go back and redesign the solution before starting development again. 
A single individual could work based on the waterfall model, though they may struggle due to flawed initial designs.

\subsubsection*{Agile}
Agile approaches are meant to be a way to solve the inflexibility that waterfall presents to developers. 
Instead of sticking to a strict five-stage process, there is an emphasis on iterating on the solution. 
Simple planning, short iteration cycles and frequent consumer feedback are key principles to the agile methodology \cite{huo2004software}.
Simple planning allows for key goals to be made while allowing for potential changes to any initial designs later on if problems are encountered.
Short iterative cycles mean that progress can be reviewed within shorter intervals and direction of the project can be made earlier if
the current outcome is not good enough or is not meeting customer demands.

The problem with the agile methodology is that it may not provide project managers with a clear indication of where a project is and where it is 
headed; especially with the large, complex, ones.
Tasks that work towards a Story or Epic that are not defined well can lead to developers focusing on the wrong things; leading to wasted time 
as time needs to be allocated for doing the task again.
Typically, in industry, you may see companies adopt some hybrid of the two approaches; an amusing term that encapsulates this would
be the ``Wagile'' approach. 

Scrum and Kanban are the two primary methodologies that classify as agile approaches.
Scrum focuses more on the commitment to ship working software or software features through a set time period called sprint cycles.
Team members also adopt certain roles, create artefacts (representing the work done) and hold ceremonies such as stand-ups and
retrospectives \cite{max2019kanbanvscrum}.
Scrum teams adopt specific roles, create unique artefacts, and hold regular ceremonies to keep things moving forward. 
The Scrum approach is likely not the best solution due to how it is likely to be most effective with a team between three and
nine people \cite{sutherlandschwaber2017scrum}. 

Kanban is an alternative approach that takes advantage of the visual representation of work that needs to be done.
It allows people in a team to understand where jobs are in the pipeline and focus effort on ensuring tasks are not left unfinished.
Unlike Scrum or even Waterfall, Kanban does not come with size limitations and allows for people to roll with it.
No roles are required either, so it makes sense for smaller teams to utilise this development model.
Just as it is with agile approaches, poor planning and lousy task definitions can lead to compromised focus among developers.
The flexibility with agile can also mean there could be a significant discrepancy between what a client wanted and what is delivered could occur.

\subsubsection*{Chosen development approach}
Though there are many other development approaches, for a single person team, taking a Kanban or Kanban-like approach is likely to be the best
fit for the project.
A basic backlog can be created around the various features that need to be implemented and focus be made on each feature to ensure
that it meets a given definition of done (DoD). 
The tasks in the backlog can be organised as some variation of a Kanban board where it provides the visual representation of tasks that need to be
completed. 

% Referencing the monolithic and n-layer approach, come to a decision which one to use and why
\subsection{Architecture approach}
It is important to understand what type of architecture is appropriate for the project as it greatly affects the planning of tasks.
The two approaches to consider for this project are monolithic and n-layer.

\subsubsection*{Monolithic}
For prototyping purposes, it can make sense to use a monolithic approach due to it being easier to deploy.
Initial prototypes, in the first couple of months, would make much sense to app
As mentioned in section \ref{monolithic}, it just is not the right approach for a long term project that requires scalability and is likely
to be worked on by many people.
Initial prototypes, in the first couple of weeks or months, can significantly benefit from being developed with a monolithic architecture approach.
Treating initial prototypes, as a sort of sandbox, where the basics of the chosen technologies can be learnt before going
ahead with a more organised architecture model.

\subsubsection*{N-layer}
The n-layered approach is common for modern web applications where client-side and server-side are completely separate
from one another. As stated in section \ref{nlayer}, a three-layer approach is typically used in the modern web and would make a great
deal of sense to use considering the nature of this project.
Flexible scaling opportunities are also available if this approach is taken as resources and instances can be increased at the desired
layers rather than just creating more instances of an entire monolithic application.
The application layer can also be utilised by more than one type of application-type in this situation; such as both web and android.
 

\subsubsection*{Chosen architecture approach}
An n-layered architecture approach will be taken as this can provide the most flexibility for future scalability.
Vertical (more compute resources) and horizontal (more instances) scaling can occur at each architectural level compared to relying on
creating multiple instances of a large monolithic application.
Three distinct layers will be defined which will be the presentation layer, application layer and the data layer.
A standalone, application layer, can allow multiple front-end clients to be incorporated as a part of the entire package.
The monolithic approach will also be utilised but will be reserved for initial prototyping only.

% This will need to cover each of the technologies that you have covered already. Just discuss why you think that the ones you want to use
% are better than the alternatives that you have already mentioned. Again justify why to believe them to be the best.
\subsection{Client side technologies and frameworks}

Along with the standard HTTP and CSS approach for creating a well structured and presented web page, JavaScript is a requirement to
transform it into a dynamic web page.
Angular and React are two prominent JavaScript packages that allow developers to create interactive, dynamic, web applications.

\subsubsection*{Angular}
The Angular framework implements the Model View Controller (MVC) approach for developing applications.
Due to this, developers need to adhere to what Angular provides. 
Much time is needed to understand how to use each aspect of Angular; can be confusing and time-consuming for those that
have no established experience in JavaScript development.

\subsubsection*{React}
React is just a library, and merely provides functionality for creating a view; excluding the \textit{M} and \textit{C} aspects of
MVC implementations \cite{mosh2018reactvangular}.
Due to the more straightforward nature of React, it is a lot easier for new-comers to start creating web applications.
React Native also lets you build mobile applications using only JavaScript.
It uses the same design as React, letting you compose a rich mobile UI using declarative components \cite{facebook2019reactnative}.

\subsubsection*{Chosen client-side approach} \label{chosenclientside}
Due to the author's lack of experience with JavaScript development, React would be the ideal approach for creating a dynamic front end application.
Rather than having to learn an entire framework (Angular), React instead provides a library that can be used to create React components.
Creating an Android application, that is consistent with the web application design, should be straightforward due to React-Native
being an extension of ReactJS; allowing native mobile application to be written entirely in JavaScript.


\subsection{Server side language and framework}
There is a range of available options for server-side solutions.
The two to consider for this project are NodeJS and Java Spring 

\subsubsection*{NodeJS}
NodeJS is a great solution for building the server side component of an application due to the vast amount of support available online.
The key advantages of using Node over other technologies comes down to lightweight nature; executing code on a single thread asynchronously.
Asynchronous development, however, can get confusing if the developer has not done it before.
Being bound to a single processor thread instantly makes NodeJS unsuitable for any high compute workloads, but is not likely to be an 
issue for this project due to no reliance on heavy compute operations.
NodeJS has the largest number of community packages available compared to other languages, through the use of the Node Package Manager (NPM).
Though this is great, as it gives develops many different options, the high activity with NPM means frameworks and APIs provided by packages
are changing way too often; leading to broken dependencies.

\subsubsection*{Java Spring}
The Spring framework for Java aims to help make Java an excellent platform for creating web applications.
Java has been around since 1995 (compared to NodeJS being released in 2009) and has developed a mature set of framework and utility packages.
The maturity of the Java community means that many of the standard packages available are not likely to have drastic changes and lead to broken dependencies that are more common-place with Node.
NodeJS is bound to using asynchronous calls for carrying out multiple operations at the same time where Java can do both multi-threaded and asynchronous executions; making it an excellent option for complex compute operations.
Spring provides many different conveniences for creating a web application and generating SpringBoot (bootstrapped spring application) is 
trivial.
Many topics that may ordinarily be complicated in pure Java can become simplified with a SpringBoot based application.
Specific behaviour, such as the runtime port, in a Spring application can be manipulated with the use of an application configuration file; removing the need
to potentially add boilerplate code.
API implementations, such as REST, can be easily implemented out of the box with the help of annotations that let you specify paths and HTTP request types.
Compared to NodeJS, Java tends to require a lot more resources and is considered ``bloated'' by some developers.
The more verbose nature of developing in a statically typed language can prove challenging to some and can take much longer to achieve a similar
(or same) result with NodeJS.

\subsubsection*{Chosen server-side language and framework}
%May need to redo this little explanation
Due to the lacklustre experience, the author has with asynchronous development (and JavaScript in general), it makes more sense to 
use the Java approach with the Spring framework.
The documentation that comes with Spring along with more standard code practices with Java Spring should allow for a more consistent
coding approach.


\subsection{Web services API}
For a client-side application to communicate and retrieve data from a server, a set of application programming interfaces (APIs)
Need to be exposed. As mentioned in section \ref{web services}, SOAP and REST are the two main approaches used in industry.
As this is a web application that needs to carry out many calls to the server to retrieve and modify information in quick
succession, it is a significant point to consider.
How well the method can integrate into JavaScript and Android client applications is also an important point to consider.

\subsubsection*{SOAP}
The Simple Object Access Protocol (SOAP) is a messaging protocol and is typically used with Web Services Description Language (WSDL) to 
provide API endpoints to be used by a client.
As it is a very mature protocol, many enterprises still utilise SOAP mostly out of legacy system support. 
Applications that may require a formal contract between the API and consumer can benefit from SOAP due to a contract being enforced through the use of WSDL. Built-in WS-Reliable messaging increases security with asynchronous executions and processes \cite{claire2015restvssoap}.
The main problems with SOAP come down to its complexity and how it may not be suitable for lots of back and forth communication
between a server and client. Operations can be slow due to how they are stateful; more initialisation and state code is required.

\subsubsection*{REST}
Representational State Transfer (REST) has become the popular choice for new APIs that are developed.
The main reasons why it has become so popular is due to its inherent simplicity. 
Developers can define a set of endpoints, to expose to the public, which client applications can consume. 
The URL endpoints provide an easy to understand representation of what resources can be accessed; nothing extra is publicly available.
A problem with this approach would be that it may not be a reliable way to create an API for some use cases, but that is where SOAP
would be the better alternative.
HTTP is typically used as the interface for carrying out operations on defined endpoints, utilising CRUD operations; making it very easy 
to understand and write services for.
Unlike SOAP, resources that are returned can be represented in more than just XML; JSON is the format of most interest. 
Using JSON based responses allow clients, written in JavaScript, to be less complicated.
The stateless and less verbose nature of REST means that less bandwidth is used in requests between a server and client; allowing
for higher performance and scalability.

\subsubsection*{Chosen web API approach}
From the comparisons made, it makes more sense to create a REST-based API.
The efficient use of bandwidth that REST provides is essential with an application that likely requires many back and forth requests
between a server and client. Any delay with requests will be noticeable by the end user can impede the overall experience.
Future scalability is important so being able to keep bandwidth usage to a minimum will is an excellent advantage over SOAP.
Being able to utilise JSON as a means to represent resources is important as the client needs to use JavaScript to consume and send requests. Simplifying this process is likely to make the development process much more manageable.


\subsection{Build automation and dependency management}
Gradle is an open-source build automation tool for Java, just like Apache Maven. \cite{muschko2014gradle}.
Considering the vast number of dependencies available for Java, a built tool such as Gradle makes it much easier to bring in
a variety of different open-source components.
The idea behind Gradle was to take the best aspects of existing tools, such as Apache Ant and Maven, and improve on them.
Gradle is JVM native which allows developers to write custom plugins and scripts with Java or Groovy; whichever is more convenient.
It can be useful to create custom jobs for a said project such as automating the creation of DockerFiles for containerising
the project.
The Project Object Model (POM) approach with Maven is the most popular choice for build automation and dependency management but is not
necessarily the best approach. 
The biggest problem with the XML based, POM file is that it can be quite hard to read through dependencies and other
configurations. 

\begin{figure}[htb]
    \begin{lstlisting}[language=XML, numbers=none]
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.15</version>
    </dependency>
    \end{lstlisting}
    \caption{Maven POM dependency entry}
\end{figure}

\begin{figure}[htb]
    \begin{lstlisting}[language=Java, numbers=none]
    compile group:'mysql', name:'mysql-connector-java', version:'8.0.15'
    compile('mysql:mysql-connector-java:8.0.15')
    compile 'mysql:mysql-connector-java:8.0.15'
    \end{lstlisting}
    \caption{Three syntax variants for adding a dependency entry to Gradle build.gradle}
\end{figure}

From these examples, it should be clear to the reader why it would be easier for a developer to read through dependencies in a Gradle build.gradle file compared to a Maven POM file. 


\subsection{Data storage solution}

Relational and non-relational databases are two approaches that can be taken for storing application information.


\subsection{Data layer technologies}
This web applications needs to store data to do with created surveys and user profile information.
When thinking of databases, most people may start thinking about SQL (relational database management system) solutions such 
as PostgreSQL or MySQL.
While this is fine, there are actually other solutions available if a relational database does not meet a business' need. 
Options such as MongoDB, which are relatively new, offer an alternative solution and come under the category of \textit{noSQL}. 

\subsubsection*{SQL databases}
A SQL database is classified as a relational database management system (RDMS) and aims to have data stored in a set of tables that
can be linked to one another through several relationship types. These relationships typically describe the structure of a certain dataset.
The relationships used are as follows (with examples): 

\begin{enumerate}
    \item one-to-one: where an entity has a singular relationship with another entity (e.g. a car has one engine)
    \item one-to-many: where an entity can have more than one relationship with another entity (e.g. a car has many wheels)
    \item many-to-many: where a number of entities have more than one relationship with another entity (e.g. a car has many wheels which have many tyres)
\end{enumerate}

\subsubsection*{noSQL databases}
% Brief explanation with examples.
As the name suggests, \textit{noSQL} is a type of database that does not use SQL and is therefore not classified as a relational database
management system (RDMS).



\subsubsection*{Chosen database approach}
Considering that structured data, surveys and user data, are the two main types of data that need to be stored by such a solution, it is logical to go with a relational database.


\subsection{Prototyping}
Since Java Spring and React have been chosen as the core technologies to use for this project, the author felt there may be value in using something
A technology framework called JHipster aims to unify many of these great technologies to create \cite{jhipster2015whatisit}: 
\begin{itemize}
    \tightlist
    \item A high-performance and robust Java stack on the server side with Spring Boot
    \item A sleek, modern, mobile-first front-end with Angular, React and Bootstrap
    \item A robust microservice architecture with the JHipster Registry, Netflix OSS, the Elastic Stack and Docker
    \item A powerful workflow to build your application with Yeoman, Webpack and Maven/Gradle
\end{itemize}

As a starting point, JHipster will be used to generate a basic Spring project to start prototyping some initial ideas and develop a
base understanding of the technologies that have been chosen for the project.


\clearpage